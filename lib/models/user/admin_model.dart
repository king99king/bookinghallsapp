// models/user/admin_model.dart

import 'package:flutter/foundation.dart';
import '../../core/constants/firebase_constants.dart';
import '../../core/utils/date_utils.dart';
import '../../core/utils/id_generator.dart';
import 'user_model.dart';

/// Admin user model with roles and permissions
class AdminModel {
  final String adminId;
  final String userId;
  final AdminRole role;
  final List<AdminPermission> permissions;
  final String? assignedBy;
  final DateTime? assignedAt;
  final bool isActive;
  final DateTime createdAt;
  final DateTime updatedAt;
  final AdminStatistics? statistics;

  AdminModel({
    required this.adminId,
    required this.userId,
    required this.role,
    required this.permissions,
    this.assignedBy,
    this.assignedAt,
    this.isActive = true,
    DateTime? createdAt,
    DateTime? updatedAt,
    this.statistics,
  }) :
        createdAt = createdAt ?? DateTime.now(),
        updatedAt = updatedAt ?? DateTime.now();

  // ========== Factory Constructors ==========

  /// Create from Firestore document
  factory AdminModel.fromJson(Map<String, dynamic> json) {
    try {
      return AdminModel(
        adminId: json[FirebaseConstants.adminIdField] as String,
        userId: json[FirebaseConstants.userIdField] as String,
        role: AdminRole.fromString(json[FirebaseConstants.roleField] as String),
        permissions: (json[FirebaseConstants.permissionsField] as List<dynamic>)
            .map((p) => AdminPermission.fromString(p as String))
            .toList(),
        assignedBy: json[FirebaseConstants.assignedByField] as String?,
        assignedAt: DateUtils.parseISODate(json[FirebaseConstants.assignedAtField] as String?),
        isActive: json[FirebaseConstants.isActiveField] as bool? ?? true,
        createdAt: DateUtils.parseISODate(json[FirebaseConstants.createdAtField] as String?) ?? DateTime.now(),
        updatedAt: DateUtils.parseISODate(json[FirebaseConstants.updatedAtField] as String?) ?? DateTime.now(),
        statistics: json['statistics'] != null
            ? AdminStatistics.fromJson(json['statistics'] as Map<String, dynamic>)
            : null,
      );
    } catch (e) {
      debugPrint('Error parsing AdminModel from JSON: $e');
      rethrow;
    }
  }

  /// Create new admin
  factory AdminModel.createNew({
    required String userId,
    required AdminRole role,
    required String assignedBy,
  }) {
    return AdminModel(
      adminId: '', // Will be generated by service
      userId: userId,
      role: role,
      permissions: role.defaultPermissions,
      assignedBy: assignedBy,
      assignedAt: DateTime.now(),
    );
  }

  // ========== JSON Conversion ==========

  Map<String, dynamic> toJson() {
    return {
      FirebaseConstants.adminIdField: adminId,
      FirebaseConstants.userIdField: userId,
      FirebaseConstants.roleField: role.value,
      FirebaseConstants.permissionsField: permissions.map((p) => p.value).toList(),
      FirebaseConstants.assignedByField: assignedBy,
      FirebaseConstants.assignedAtField: assignedAt != null ? DateUtils.toISOString(assignedAt!) : null,
      FirebaseConstants.isActiveField: isActive,
      FirebaseConstants.createdAtField: DateUtils.toISOString(createdAt),
      FirebaseConstants.updatedAtField: DateUtils.toISOString(updatedAt),
      'statistics': statistics?.toJson(),
    };
  }

  // ========== Validation ==========

  List<String> validate() {
    final errors = <String>[];

    // Validate admin ID
    if (adminId.isNotEmpty && !IdGenerator.isValidAdminId(adminId)) {
      errors.add('Invalid admin ID format');
    }

    // Validate user ID
    if (!IdGenerator.isValidUserId(userId)) {
      errors.add('Invalid user ID format');
    }

    // Validate assigned by
    if (assignedBy != null && !IdGenerator.isValidAdminId(assignedBy!)) {
      errors.add('Invalid assignedBy admin ID format');
    }

    // Validate permissions for role
    final invalidPermissions = permissions.where((p) => !role.allowedPermissions.contains(p)).toList();
    if (invalidPermissions.isNotEmpty) {
      errors.add('Permissions ${invalidPermissions.map((p) => p.value).join(', ')} not allowed for role ${role.value}');
    }

    return errors;
  }

  bool get isValid => validate().isEmpty;

  // ========== Permission Checks ==========

  /// Check if admin has specific permission
  bool hasPermission(AdminPermission permission) {
    return permissions.contains(permission);
  }

  /// Check if admin can manage users
  bool get canManageUsers => hasPermission(AdminPermission.manageUsers);

  /// Check if admin can manage halls
  bool get canManageHalls => hasPermission(AdminPermission.manageHalls);

  /// Check if admin can manage bookings
  bool get canManageBookings => hasPermission(AdminPermission.manageBookings);

  /// Check if admin can manage payments
  bool get canManagePayments => hasPermission(AdminPermission.managePayments);

  /// Check if admin can view analytics
  bool get canViewAnalytics => hasPermission(AdminPermission.viewAnalytics);

  /// Check if admin can manage settings
  bool get canManageSettings => hasPermission(AdminPermission.manageSettings);

  /// Check if admin can manage notifications
  bool get canManageNotifications => hasPermission(AdminPermission.manageNotifications);

  /// Check if admin can manage reviews
  bool get canManageReviews => hasPermission(AdminPermission.manageReviews);

  /// Check if admin is super admin
  bool get isSuperAdmin => role == AdminRole.superAdmin;

  /// Check if admin can assign other admins
  bool get canAssignAdmins => isSuperAdmin;

  /// Check if admin can modify system settings
  bool get canModifySystemSettings => isSuperAdmin && hasPermission(AdminPermission.manageSettings);

  // ========== Role Management ==========

  /// Get role display name
  String getRoleDisplayName(String? languageCode) {
    final isArabic = languageCode == 'ar';
    switch (role) {
      case AdminRole.superAdmin:
        return isArabic ? 'مدير عام' : 'Super Admin';
      case AdminRole.contentModerator:
        return isArabic ? 'مشرف المحتوى' : 'Content Moderator';
      case AdminRole.support:
        return isArabic ? 'دعم فني' : 'Support';
      case AdminRole.finance:
        return isArabic ? 'مالية' : 'Finance';
    }
  }

  /// Get permissions display names
  List<String> getPermissionsDisplayNames(String? languageCode) {
    return permissions.map((p) => p.getDisplayName(languageCode)).toList();
  }

  /// Check if admin can perform action on target user
  bool canPerformActionOnUser(UserModel targetUser) {
    // Super admin can manage everyone except other super admins
    if (isSuperAdmin) {
      return true; // Can manage everyone
    }

    // Non-super admins cannot manage admin users
    if (targetUser.isAdmin) {
      return false;
    }

    // Check specific permissions for user management
    return canManageUsers;
  }

  /// Check if admin can access specific hall management features
  bool canAccessHallFeature(HallManagementFeature feature) {
    if (!canManageHalls) return false;

    switch (feature) {
      case HallManagementFeature.approve:
      case HallManagementFeature.reject:
        return isSuperAdmin || role == AdminRole.contentModerator;
      case HallManagementFeature.view:
      case HallManagementFeature.edit:
        return true; // All hall managers can view and edit
      case HallManagementFeature.delete:
        return isSuperAdmin;
    }
  }

  // ========== Activity Tracking ==========

  /// Get admin activity summary
  String getActivitySummary(String? languageCode) {
    if (statistics == null) return '';

    final isArabic = languageCode == 'ar';
    final stats = statistics!;

    if (isArabic) {
      return 'تمت معالجة ${stats.totalActionsPerformed} إجراء، '
          '${stats.usersManaged} مستخدم، '
          '${stats.hallsProcessed} قاعة';
    } else {
      return 'Processed ${stats.totalActionsPerformed} actions, '
          'managed ${stats.usersManaged} users, '
          '${stats.hallsProcessed} halls';
    }
  }

  /// Check if admin was recently active
  bool get isRecentlyActive {
    if (statistics?.lastActionAt == null) return false;
    final sevenDaysAgo = DateTime.now().subtract(const Duration(days: 7));
    return statistics!.lastActionAt!.isAfter(sevenDaysAgo);
  }

  /// Get time since last action
  String? getTimeSinceLastAction(String? languageCode) {
    if (statistics?.lastActionAt == null) return null;
    return DateUtils.formatTimeDifference(statistics!.lastActionAt!, languageCode: languageCode);
  }

  // ========== Update Methods ==========

  /// Update permissions
  AdminModel updatePermissions(List<AdminPermission> newPermissions) {
    // Validate permissions for role
    final invalidPermissions = newPermissions.where((p) => !role.allowedPermissions.contains(p)).toList();
    if (invalidPermissions.isNotEmpty) {
      throw ArgumentError('Permissions ${invalidPermissions.map((p) => p.value).join(', ')} not allowed for role ${role.value}');
    }

    return copyWith(
      permissions: newPermissions,
      updatedAt: DateTime.now(),
    );
  }

  /// Update role (and adjust permissions accordingly)
  AdminModel updateRole(AdminRole newRole, {String? updatedBy}) {
    // Filter permissions to only include those allowed for new role
    final validPermissions = permissions.where((p) => newRole.allowedPermissions.contains(p)).toList();

    // Add default permissions for new role that aren't already included
    final defaultPermissions = newRole.defaultPermissions.where((p) => !validPermissions.contains(p));
    validPermissions.addAll(defaultPermissions);

    return copyWith(
      role: newRole,
      permissions: validPermissions,
      updatedAt: DateTime.now(),
    );
  }

  /// Deactivate admin
  AdminModel deactivate() {
    return copyWith(
      isActive: false,
      updatedAt: DateTime.now(),
    );
  }

  /// Reactivate admin
  AdminModel reactivate() {
    return copyWith(
      isActive: true,
      updatedAt: DateTime.now(),
    );
  }

  /// Update statistics
  AdminModel updateStatistics(AdminStatistics newStatistics) {
    return copyWith(
      statistics: newStatistics,
      updatedAt: DateTime.now(),
    );
  }

  // ========== Copy With ==========

  AdminModel copyWith({
    String? adminId,
    String? userId,
    AdminRole? role,
    List<AdminPermission>? permissions,
    String? assignedBy,
    DateTime? assignedAt,
    bool? isActive,
    DateTime? createdAt,
    DateTime? updatedAt,
    AdminStatistics? statistics,
  }) {
    return AdminModel(
      adminId: adminId ?? this.adminId,
      userId: userId ?? this.userId,
      role: role ?? this.role,
      permissions: permissions ?? this.permissions,
      assignedBy: assignedBy ?? this.assignedBy,
      assignedAt: assignedAt ?? this.assignedAt,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      statistics: statistics ?? this.statistics,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is AdminModel && other.adminId == adminId;
  }

  @override
  int get hashCode => adminId.hashCode;

  @override
  String toString() {
    return 'AdminModel(adminId: $adminId, userId: $userId, role: ${role.value}, isActive: $isActive)';
  }
}

// ========== Admin Enums ==========

/// Admin roles with hierarchical permissions
enum AdminRole {
  superAdmin('super_admin'),
  contentModerator('content_moderator'),
  support('support'),
  finance('finance');

  const AdminRole(this.value);
  final String value;

  static AdminRole fromString(String value) {
    return AdminRole.values.firstWhere(
          (role) => role.value == value,
      orElse: () => AdminRole.support,
    );
  }

  /// Get allowed permissions for this role
  List<AdminPermission> get allowedPermissions {
    switch (this) {
      case AdminRole.superAdmin:
        return AdminPermission.values; // All permissions
      case AdminRole.contentModerator:
        return [
          AdminPermission.manageHalls,
          AdminPermission.manageReviews,
          AdminPermission.manageNotifications,
          AdminPermission.viewAnalytics,
        ];
      case AdminRole.support:
        return [
          AdminPermission.manageUsers,
          AdminPermission.manageBookings,
          AdminPermission.viewAnalytics,
        ];
      case AdminRole.finance:
        return [
          AdminPermission.managePayments,
          AdminPermission.viewAnalytics,
        ];
    }
  }

  /// Get default permissions assigned when creating new admin with this role
  List<AdminPermission> get defaultPermissions {
    switch (this) {
      case AdminRole.superAdmin:
        return allowedPermissions; // All permissions
      case AdminRole.contentModerator:
        return [
          AdminPermission.manageHalls,
          AdminPermission.manageReviews,
          AdminPermission.viewAnalytics,
        ];
      case AdminRole.support:
        return [
          AdminPermission.manageUsers,
          AdminPermission.manageBookings,
        ];
      case AdminRole.finance:
        return [
          AdminPermission.managePayments,
          AdminPermission.viewAnalytics,
        ];
    }
  }
}

/// Admin permissions
enum AdminPermission {
  manageUsers('manage_users'),
  manageHalls('manage_halls'),
  manageBookings('manage_bookings'),
  managePayments('manage_payments'),
  viewAnalytics('view_analytics'),
  manageSettings('manage_settings'),
  manageNotifications('manage_notifications'),
  manageReviews('manage_reviews');

  const AdminPermission(this.value);
  final String value;

  static AdminPermission fromString(String value) {
    return AdminPermission.values.firstWhere(
          (permission) => permission.value == value,
      orElse: () => AdminPermission.viewAnalytics,
    );
  }

  /// Get display name for permission
  String getDisplayName(String? languageCode) {
    final isArabic = languageCode == 'ar';
    switch (this) {
      case AdminPermission.manageUsers:
        return isArabic ? 'إدارة المستخدمين' : 'Manage Users';
      case AdminPermission.manageHalls:
        return isArabic ? 'إدارة القاعات' : 'Manage Halls';
      case AdminPermission.manageBookings:
        return isArabic ? 'إدارة الحجوزات' : 'Manage Bookings';
      case AdminPermission.managePayments:
        return isArabic ? 'إدارة المدفوعات' : 'Manage Payments';
      case AdminPermission.viewAnalytics:
        return isArabic ? 'عرض التحليلات' : 'View Analytics';
      case AdminPermission.manageSettings:
        return isArabic ? 'إدارة الإعدادات' : 'Manage Settings';
      case AdminPermission.manageNotifications:
        return isArabic ? 'إدارة الإشعارات' : 'Manage Notifications';
      case AdminPermission.manageReviews:
        return isArabic ? 'إدارة التقييمات' : 'Manage Reviews';
    }
  }
}

/// Hall management features that require permission checks
enum HallManagementFeature {
  view,
  edit,
  approve,
  reject,
  delete,
}

// ========== Admin Statistics ==========

/// Admin activity statistics
class AdminStatistics {
  final int totalActionsPerformed;
  final int usersManaged;
  final int hallsProcessed;
  final int bookingsHandled;
  final int paymentsProcessed;
  final int reviewsModerated;
  final DateTime? lastActionAt;
  final Map<String, int> actionsByType;

  AdminStatistics({
    this.totalActionsPerformed = 0,
    this.usersManaged = 0,
    this.hallsProcessed = 0,
    this.bookingsHandled = 0,
    this.paymentsProcessed = 0,
    this.reviewsModerated = 0,
    this.lastActionAt,
    this.actionsByType = const {},
  });

  factory AdminStatistics.fromJson(Map<String, dynamic> json) {
    return AdminStatistics(
      totalActionsPerformed: json['totalActionsPerformed'] as int? ?? 0,
      usersManaged: json['usersManaged'] as int? ?? 0,
      hallsProcessed: json['hallsProcessed'] as int? ?? 0,
      bookingsHandled: json['bookingsHandled'] as int? ?? 0,
      paymentsProcessed: json['paymentsProcessed'] as int? ?? 0,
      reviewsModerated: json['reviewsModerated'] as int? ?? 0,
      lastActionAt: DateUtils.parseISODate(json['lastActionAt'] as String?),
      actionsByType: Map<String, int>.from(json['actionsByType'] as Map<String, dynamic>? ?? {}),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'totalActionsPerformed': totalActionsPerformed,
      'usersManaged': usersManaged,
      'hallsProcessed': hallsProcessed,
      'bookingsHandled': bookingsHandled,
      'paymentsProcessed': paymentsProcessed,
      'reviewsModerated': reviewsModerated,
      'lastActionAt': lastActionAt != null ? DateUtils.toISOString(lastActionAt!) : null,
      'actionsByType': actionsByType,
    };
  }

  /// Record a new action
  AdminStatistics recordAction(AdminActionType actionType) {
    final newActionsByType = Map<String, int>.from(actionsByType);
    newActionsByType[actionType.value] = (newActionsByType[actionType.value] ?? 0) + 1;

    return AdminStatistics(
      totalActionsPerformed: totalActionsPerformed + 1,
      usersManaged: actionType == AdminActionType.userAction ? usersManaged + 1 : usersManaged,
      hallsProcessed: actionType == AdminActionType.hallAction ? hallsProcessed + 1 : hallsProcessed,
      bookingsHandled: actionType == AdminActionType.bookingAction ? bookingsHandled + 1 : bookingsHandled,
      paymentsProcessed: actionType == AdminActionType.paymentAction ? paymentsProcessed + 1 : paymentsProcessed,
      reviewsModerated: actionType == AdminActionType.reviewAction ? reviewsModerated + 1 : reviewsModerated,
      lastActionAt: DateTime.now(),
      actionsByType: newActionsByType,
    );
  }

  /// Get most common action type
  String? get mostCommonActionType {
    if (actionsByType.isEmpty) return null;

    String mostCommon = actionsByType.keys.first;
    int maxCount = actionsByType.values.first;

    for (final entry in actionsByType.entries) {
      if (entry.value > maxCount) {
        maxCount = entry.value;
        mostCommon = entry.key;
      }
    }

    return mostCommon;
  }

  /// Get efficiency score (actions per day since creation)
  double getEfficiencyScore(DateTime adminCreatedAt) {
    final daysSinceCreated = DateTime.now().difference(adminCreatedAt).inDays;
    if (daysSinceCreated == 0) return totalActionsPerformed.toDouble();
    return totalActionsPerformed / daysSinceCreated;
  }
}

/// Types of admin actions for statistics
enum AdminActionType {
  userAction('user_action'),
  hallAction('hall_action'),
  bookingAction('booking_action'),
  paymentAction('payment_action'),
  reviewAction('review_action'),
  settingAction('setting_action');

  const AdminActionType(this.value);
  final String value;
}