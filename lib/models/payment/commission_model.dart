// models/payment/commission_model.dart

import 'package:cloud_firestore/cloud_firestore.dart';
import '../../core/constants/firebase_constants.dart';
import '../../core/constants/app_constants.dart';
import '../../core/utils/validators.dart';
import '../../core/utils/date_utils.dart';
import '../../core/utils/id_generator.dart';

/// Comprehensive commission model for tracking and managing commissions
class CommissionModel {
  final String commissionId;
  final String? paymentId;
  final String? bookingId;
  final String? hallId;
  final String? ownerId;
  final String? customerId;
  final CommissionType type;
  final double baseAmount;
  final double commissionPercent;
  final double commissionAmount;
  final String currency;
  final CommissionStatus status;
  final DateTime createdAt;
  final DateTime? processedAt;
  final DateTime? paidAt;
  final String? paymentTransactionId;
  final CommissionRule? appliedRule;
  final Map<String, dynamic>? calculation;
  final Map<String, dynamic>? metadata;
  final List<CommissionStatusHistory> statusHistory;

  CommissionModel({
    required this.commissionId,
    this.paymentId,
    this.bookingId,
    this.hallId,
    this.ownerId,
    this.customerId,
    required this.type,
    required this.baseAmount,
    required this.commissionPercent,
    required this.commissionAmount,
    this.currency = AppConstants.defaultCurrency,
    required this.status,
    DateTime? createdAt,
    this.processedAt,
    this.paidAt,
    this.paymentTransactionId,
    this.appliedRule,
    this.calculation,
    this.metadata,
    this.statusHistory = const [],
  }) : createdAt = createdAt ?? DateTime.now();

  // ========== Factory Constructors ==========

  /// Create from Firestore document
  factory CommissionModel.fromJson(Map<String, dynamic> json) {
    try {
      return CommissionModel(
        commissionId: Validators.validateString(json['commissionId'], 'Commission ID'),
        paymentId: json[FirebaseConstants.paymentIdField] as String?,
        bookingId: json[FirebaseConstants.bookingIdField] as String?,
        hallId: json[FirebaseConstants.hallIdField] as String?,
        ownerId: json[FirebaseConstants.ownerIdField] as String?,
        customerId: json['customerId'] as String?,
        type: CommissionType.values.firstWhere(
              (e) => e.name == json['type'],
          orElse: () => CommissionType.customer,
        ),
        baseAmount: Validators.validatePositiveDouble(json['baseAmount'], 'Base amount'),
        commissionPercent: Validators.validatePositiveDouble(json['commissionPercent'], 'Commission percent'),
        commissionAmount: Validators.validatePositiveDouble(json['commissionAmount'], 'Commission amount'),
        currency: json['currency'] as String? ?? AppConstants.defaultCurrency,
        status: CommissionStatus.values.firstWhere(
              (e) => e.name == json[FirebaseConstants.statusField],
          orElse: () => CommissionStatus.pending,
        ),
        createdAt: DateUtils.parseTimestamp(json[FirebaseConstants.createdAtField]) ?? DateTime.now(),
        processedAt: DateUtils.parseTimestamp(json['processedAt']),
        paidAt: DateUtils.parseTimestamp(json['paidAt']),
        paymentTransactionId: json['paymentTransactionId'] as String?,
        appliedRule: json['appliedRule'] != null
            ? CommissionRule.fromJson(json['appliedRule'] as Map<String, dynamic>)
            : null,
        calculation: json['calculation'] as Map<String, dynamic>?,
        metadata: json['metadata'] as Map<String, dynamic>?,
        statusHistory: (json['statusHistory'] as List<dynamic>?)
            ?.map((e) => CommissionStatusHistory.fromJson(e as Map<String, dynamic>))
            .toList() ?? [],
      );
    } catch (e) {
      throw ModelParseException('Failed to parse CommissionModel: $e');
    }
  }

  /// Create new commission
  factory CommissionModel.create({
    String? paymentId,
    String? bookingId,
    String? hallId,
    String? ownerId,
    String? customerId,
    required CommissionType type,
    required double baseAmount,
    required double commissionPercent,
    String currency = AppConstants.defaultCurrency,
    CommissionRule? appliedRule,
    Map<String, dynamic>? metadata,
  }) {
    final commissionId = IdGenerator.generateCommissionId();
    final commissionAmount = baseAmount * (commissionPercent / 100);
    final now = DateTime.now();

    return CommissionModel(
      commissionId: '', // Will be generated by service
      paymentId: paymentId,
      bookingId: bookingId,
      hallId: hallId,
      ownerId: ownerId,
      customerId: customerId,
      type: type,
      baseAmount: baseAmount,
      commissionPercent: commissionPercent,
      commissionAmount: commissionAmount,
      currency: currency,
      status: CommissionStatus.pending,
      createdAt: now,
      appliedRule: appliedRule,
      calculation: {
        'baseAmount': baseAmount,
        'commissionPercent': commissionPercent,
        'commissionAmount': commissionAmount,
        'calculatedAt': now.toIso8601String(),
      },
      metadata: metadata,
      statusHistory: [
        CommissionStatusHistory(
          status: CommissionStatus.pending,
          timestamp: now,
          notes: 'Commission created',
        ),
      ],
    );
  }

  /// Create customer commission
  factory CommissionModel.customerCommission({
    required String paymentId,
    required String bookingId,
    required String hallId,
    required String customerId,
    required double baseAmount,
    required double commissionPercent,
    CommissionRule? appliedRule,
    Map<String, dynamic>? metadata,
  }) {
    return CommissionModel.create(
      paymentId: paymentId,
      bookingId: bookingId,
      hallId: hallId,
      customerId: customerId,
      type: CommissionType.customer,
      baseAmount: baseAmount,
      commissionPercent: commissionPercent,
      appliedRule: appliedRule,
      metadata: metadata,
    );
  }

  /// Create owner commission
  factory CommissionModel.ownerCommission({
    required String paymentId,
    required String bookingId,
    required String hallId,
    required String ownerId,
    required double baseAmount,
    required double commissionPercent,
    CommissionRule? appliedRule,
    Map<String, dynamic>? metadata,
  }) {
    return CommissionModel.create(
      paymentId: paymentId,
      bookingId: bookingId,
      hallId: hallId,
      ownerId: ownerId,
      type: CommissionType.owner,
      baseAmount: baseAmount,
      commissionPercent: commissionPercent,
      appliedRule: appliedRule,
      metadata: metadata,
    );
  }

  /// Create platform commission
  factory CommissionModel.platformCommission({
    required String paymentId,
    required String bookingId,
    required String hallId,
    required double baseAmount,
    required double commissionPercent,
    CommissionRule? appliedRule,
    Map<String, dynamic>? metadata,
  }) {
    return CommissionModel.create(
      paymentId: paymentId,
      bookingId: bookingId,
      hallId: hallId,
      type: CommissionType.platform,
      baseAmount: baseAmount,
      commissionPercent: commissionPercent,
      appliedRule: appliedRule,
      metadata: metadata,
    );
  }

  // ========== Serialization ==========

  Map<String, dynamic> toJson() {
    return {
      'commissionId': commissionId,
      FirebaseConstants.paymentIdField: paymentId,
      FirebaseConstants.bookingIdField: bookingId,
      FirebaseConstants.hallIdField: hallId,
      FirebaseConstants.ownerIdField: ownerId,
      'customerId': customerId,
      'type': type.name,
      'baseAmount': baseAmount,
      'commissionPercent': commissionPercent,
      'commissionAmount': commissionAmount,
      'currency': currency,
      FirebaseConstants.statusField: status.name,
      FirebaseConstants.createdAtField: FieldValue.serverTimestamp(),
      'processedAt': processedAt != null ? Timestamp.fromDate(processedAt!) : null,
      'paidAt': paidAt != null ? Timestamp.fromDate(paidAt!) : null,
      'paymentTransactionId': paymentTransactionId,
      'appliedRule': appliedRule?.toJson(),
      'calculation': calculation,
      'metadata': metadata,
      'statusHistory': statusHistory.map((h) => h.toJson()).toList(),
    };
  }

  // ========== Business Logic Methods ==========

  /// Check if commission is pending
  bool isPending() => status == CommissionStatus.pending;

  /// Check if commission is processed
  bool isProcessed() => status == CommissionStatus.processed;

  /// Check if commission is paid
  bool isPaid() => status == CommissionStatus.paid;

  /// Check if commission is disputed
  bool isDisputed() => status == CommissionStatus.disputed;

  /// Check if commission is cancelled
  bool isCancelled() => status == CommissionStatus.cancelled;

  /// Check if commission can be processed
  bool canBeProcessed() {
    return status == CommissionStatus.pending;
  }

  /// Check if commission can be paid
  bool canBePaid() {
    return status == CommissionStatus.processed;
  }

  /// Check if commission can be disputed
  bool canBeDisputed() {
    return status == CommissionStatus.processed || status == CommissionStatus.paid;
  }

  /// Get commission age in days
  int getAgeInDays() {
    return DateTime.now().difference(createdAt).inDays;
  }

  /// Check if commission is overdue for payment
  bool isOverdue() {
    if (status != CommissionStatus.processed) return false;

    final daysSinceProcessed = processedAt != null
        ? DateTime.now().difference(processedAt!).inDays
        : 0;

    return daysSinceProcessed > AppConstants.commissionPaymentDueDays;
  }

  /// Get commission type display text
  String getTypeDisplayText(String languageCode) {
    final typeTranslations = {
      'customer': {'en': 'Customer Commission', 'ar': 'عمولة العميل'},
      'owner': {'en': 'Owner Commission', 'ar': 'عمولة المالك'},
      'platform': {'en': 'Platform Commission', 'ar': 'عمولة المنصة'},
      'referral': {'en': 'Referral Commission', 'ar': 'عمولة الإحالة'},
      'bonus': {'en': 'Bonus Commission', 'ar': 'عمولة المكافأة'},
    };

    return typeTranslations[type.name]?[languageCode] ?? type.name;
  }

  /// Get status display text
  String getStatusDisplayText(String languageCode) {
    final statusTranslations = {
      'pending': {'en': 'Pending', 'ar': 'في الانتظار'},
      'processed': {'en': 'Processed', 'ar': 'معالج'},
      'paid': {'en': 'Paid', 'ar': 'مدفوع'},
      'disputed': {'en': 'Disputed', 'ar': 'متنازع عليه'},
      'cancelled': {'en': 'Cancelled', 'ar': 'ملغي'},
    };

    return statusTranslations[status.name]?[languageCode] ?? status.name;
  }

  /// Format commission amount with currency
  String getFormattedAmount({String? languageCode}) {
    final formatted = commissionAmount.toStringAsFixed(3);
    final currencySymbol = AppConstants.currencySymbol;

    if (languageCode == 'ar') {
      return '$formatted $currencySymbol';
    }
    return '$currencySymbol $formatted';
  }

  /// Get effective rate based on applied rule
  double getEffectiveRate() {
    return appliedRule?.effectiveRate ?? commissionPercent;
  }

  // ========== Update Methods ==========

  /// Process commission
  CommissionModel process() {
    final now = DateTime.now();
    final newHistory = List<CommissionStatusHistory>.from(statusHistory)
      ..add(CommissionStatusHistory(
        status: CommissionStatus.processed,
        timestamp: now,
        notes: 'Commission processed',
      ));

    return copyWith(
      status: CommissionStatus.processed,
      processedAt: now,
      statusHistory: newHistory,
    );
  }

  /// Mark commission as paid
  CommissionModel markAsPaid(String transactionId) {
    final now = DateTime.now();
    final newHistory = List<CommissionStatusHistory>.from(statusHistory)
      ..add(CommissionStatusHistory(
        status: CommissionStatus.paid,
        timestamp: now,
        notes: 'Commission paid - Transaction: $transactionId',
      ));

    return copyWith(
      status: CommissionStatus.paid,
      paidAt: now,
      paymentTransactionId: transactionId,
      statusHistory: newHistory,
    );
  }

  /// Dispute commission
  CommissionModel dispute(String reason) {
    final now = DateTime.now();
    final newHistory = List<CommissionStatusHistory>.from(statusHistory)
      ..add(CommissionStatusHistory(
        status: CommissionStatus.disputed,
        timestamp: now,
        notes: 'Commission disputed: $reason',
      ));

    return copyWith(
      status: CommissionStatus.disputed,
      statusHistory: newHistory,
    );
  }

  /// Cancel commission
  CommissionModel cancel(String reason) {
    final now = DateTime.now();
    final newHistory = List<CommissionStatusHistory>.from(statusHistory)
      ..add(CommissionStatusHistory(
        status: CommissionStatus.cancelled,
        timestamp: now,
        notes: 'Commission cancelled: $reason',
      ));

    return copyWith(
      status: CommissionStatus.cancelled,
      statusHistory: newHistory,
    );
  }

  // ========== Copy With ==========

  CommissionModel copyWith({
    String? commissionId,
    String? paymentId,
    String? bookingId,
    String? hallId,
    String? ownerId,
    String? customerId,
    CommissionType? type,
    double? baseAmount,
    double? commissionPercent,
    double? commissionAmount,
    String? currency,
    CommissionStatus? status,
    DateTime? createdAt,
    DateTime? processedAt,
    DateTime? paidAt,
    String? paymentTransactionId,
    CommissionRule? appliedRule,
    Map<String, dynamic>? calculation,
    Map<String, dynamic>? metadata,
    List<CommissionStatusHistory>? statusHistory,
  }) {
    return CommissionModel(
      commissionId: commissionId ?? this.commissionId,
      paymentId: paymentId ?? this.paymentId,
      bookingId: bookingId ?? this.bookingId,
      hallId: hallId ?? this.hallId,
      ownerId: ownerId ?? this.ownerId,
      customerId: customerId ?? this.customerId,
      type: type ?? this.type,
      baseAmount: baseAmount ?? this.baseAmount,
      commissionPercent: commissionPercent ?? this.commissionPercent,
      commissionAmount: commissionAmount ?? this.commissionAmount,
      currency: currency ?? this.currency,
      status: status ?? this.status,
      createdAt: createdAt ?? this.createdAt,
      processedAt: processedAt ?? this.processedAt,
      paidAt: paidAt ?? this.paidAt,
      paymentTransactionId: paymentTransactionId ?? this.paymentTransactionId,
      appliedRule: appliedRule ?? this.appliedRule,
      calculation: calculation ?? this.calculation,
      metadata: metadata ?? this.metadata,
      statusHistory: statusHistory ?? this.statusHistory,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is CommissionModel && other.commissionId == commissionId;
  }

  @override
  int get hashCode => commissionId.hashCode;

  @override
  String toString() => 'CommissionModel(id: $commissionId, amount: $commissionAmount, type: $type)';
}

// ========== Supporting Enums ==========

/// Commission type enum
enum CommissionType {
  customer,
  owner,
  platform,
  referral,
  bonus,
}

/// Commission status enum
enum CommissionStatus {
  pending,
  processed,
  paid,
  disputed,
  cancelled,
}

// ========== Supporting Models ==========

/// Commission rule for calculating commissions
class CommissionRule {
  final String ruleId;
  final String name;
  final String? nameArabic;
  final CommissionType type;
  final double baseRate;
  final double minRate;
  final double maxRate;
  final List<CommissionTier> tiers;
  final Map<String, dynamic>? conditions;
  final bool isActive;
  final DateTime createdAt;
  final DateTime? updatedAt;

  CommissionRule({
    required this.ruleId,
    required this.name,
    this.nameArabic,
    required this.type,
    required this.baseRate,
    required this.minRate,
    required this.maxRate,
    this.tiers = const [],
    this.conditions,
    this.isActive = true,
    DateTime? createdAt,
    this.updatedAt,
  }) : createdAt = createdAt ?? DateTime.now();

  factory CommissionRule.fromJson(Map<String, dynamic> json) {
    return CommissionRule(
      ruleId: json['ruleId'] as String,
      name: json['name'] as String,
      nameArabic: json['nameArabic'] as String?,
      type: CommissionType.values.firstWhere(
            (e) => e.name == json['type'],
        orElse: () => CommissionType.customer,
      ),
      baseRate: (json['baseRate'] as num).toDouble(),
      minRate: (json['minRate'] as num).toDouble(),
      maxRate: (json['maxRate'] as num).toDouble(),
      tiers: (json['tiers'] as List<dynamic>?)
          ?.map((e) => CommissionTier.fromJson(e as Map<String, dynamic>))
          .toList() ?? [],
      conditions: json['conditions'] as Map<String, dynamic>?,
      isActive: json['isActive'] as bool? ?? true,
      createdAt: DateUtils.parseTimestamp(json['createdAt']) ?? DateTime.now(),
      updatedAt: DateUtils.parseTimestamp(json['updatedAt']),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'ruleId': ruleId,
      'name': name,
      'nameArabic': nameArabic,
      'type': type.name,
      'baseRate': baseRate,
      'minRate': minRate,
      'maxRate': maxRate,
      'tiers': tiers.map((t) => t.toJson()).toList(),
      'conditions': conditions,
      'isActive': isActive,
      'createdAt': Timestamp.fromDate(createdAt),
      'updatedAt': updatedAt != null ? Timestamp.fromDate(updatedAt!) : null,
    };
  }

  /// Calculate effective rate for given amount
  double calculateRate(double amount) {
    // If no tiers, return base rate
    if (tiers.isEmpty) return baseRate;

    // Find applicable tier
    for (final tier in tiers) {
      if (amount >= tier.minAmount && (tier.maxAmount == null || amount <= tier.maxAmount!)) {
        return tier.rate;
      }
    }

    // Return base rate if no tier matches
    return baseRate;
  }

  /// Get effective rate (same as calculateRate but for consistency)
  double get effectiveRate => baseRate;

  /// Check if rule applies to given conditions
  bool appliesTo(Map<String, dynamic> context) {
    if (conditions == null || conditions!.isEmpty) return true;

    // Check each condition
    for (final entry in conditions!.entries) {
      final key = entry.key;
      final value = entry.value;

      if (!context.containsKey(key) || context[key] != value) {
        return false;
      }
    }

    return true;
  }
}

/// Commission tier for tiered commission rates
class CommissionTier {
  final double minAmount;
  final double? maxAmount;
  final double rate;
  final String? description;

  CommissionTier({
    required this.minAmount,
    this.maxAmount,
    required this.rate,
    this.description,
  });

  factory CommissionTier.fromJson(Map<String, dynamic> json) {
    return CommissionTier(
      minAmount: (json['minAmount'] as num).toDouble(),
      maxAmount: (json['maxAmount'] as num?)?.toDouble(),
      rate: (json['rate'] as num).toDouble(),
      description: json['description'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'minAmount': minAmount,
      'maxAmount': maxAmount,
      'rate': rate,
      'description': description,
    };
  }

  /// Check if amount falls within this tier
  bool containsAmount(double amount) {
    return amount >= minAmount && (maxAmount == null || amount <= maxAmount!);
  }

  @override
  String toString() => 'CommissionTier($minAmount-${maxAmount ?? '∞'}: $rate%)';
}

/// Commission status history tracking
class CommissionStatusHistory {
  final CommissionStatus status;
  final DateTime timestamp;
  final String? notes;
  final Map<String, dynamic>? metadata;

  CommissionStatusHistory({
    required this.status,
    required this.timestamp,
    this.notes,
    this.metadata,
  });

  factory CommissionStatusHistory.fromJson(Map<String, dynamic> json) {
    return CommissionStatusHistory(
      status: CommissionStatus.values.firstWhere(
            (e) => e.name == json['status'],
        orElse: () => CommissionStatus.pending,
      ),
      timestamp: DateUtils.parseTimestamp(json['timestamp']) ?? DateTime.now(),
      notes: json['notes'] as String?,
      metadata: json['metadata'] as Map<String, dynamic>?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'status': status.name,
      'timestamp': Timestamp.fromDate(timestamp),
      'notes': notes,
      'metadata': metadata,
    };
  }
}

/// Commission summary for reporting
class CommissionSummary {
  final CommissionType type;
  final double totalCommissions;
  final double paidCommissions;
  final double pendingCommissions;
  final int totalCount;
  final int paidCount;
  final int pendingCount;
  final DateTime? lastCommissionDate;

  CommissionSummary({
    required this.type,
    required this.totalCommissions,
    required this.paidCommissions,
    required this.pendingCommissions,
    required this.totalCount,
    required this.paidCount,
    required this.pendingCount,
    this.lastCommissionDate,
  });

  factory CommissionSummary.fromCommissions(List<CommissionModel> commissions, CommissionType type) {
    final filteredCommissions = commissions.where((c) => c.type == type).toList();

    double totalCommissions = 0.0;
    double paidCommissions = 0.0;
    double pendingCommissions = 0.0;
    int paidCount = 0;
    int pendingCount = 0;
    DateTime? lastCommissionDate;

    for (final commission in filteredCommissions) {
      totalCommissions += commission.commissionAmount;

      if (commission.isPaid()) {
        paidCommissions += commission.commissionAmount;
        paidCount++;
      } else if (commission.isPending() || commission.isProcessed()) {
        pendingCommissions += commission.commissionAmount;
        pendingCount++;
      }

      if (lastCommissionDate == null || commission.createdAt.isAfter(lastCommissionDate)) {
        lastCommissionDate = commission.createdAt;
      }
    }

    return CommissionSummary(
      type: type,
      totalCommissions: totalCommissions,
      paidCommissions: paidCommissions,
      pendingCommissions: pendingCommissions,
      totalCount: filteredCommissions.length,
      paidCount: paidCount,
      pendingCount: pendingCount,
      lastCommissionDate: lastCommissionDate,
    );
  }

  /// Get payment percentage
  double getPaymentPercentage() {
    if (totalCommissions == 0) return 0.0;
    return (paidCommissions / totalCommissions) * 100;
  }

  @override
  String toString() => 'CommissionSummary($type: $totalCommissions, paid: $paidCommissions)';
}

/// Custom exception for commission model parsing errors
class ModelParseException implements Exception {
  final String message;
  ModelParseException(this.message);

  @override
  String toString() => 'ModelParseException: $message';
}