// models/payment/transaction_model.dart

import 'package:cloud_firestore/cloud_firestore.dart';
import '../../core/constants/firebase_constants.dart';
import '../../core/constants/app_constants.dart';
import '../../core/utils/validators.dart';
import '../../core/utils/date_utils.dart';
import '../../core/utils/id_generator.dart';

/// Comprehensive transaction model for tracking all financial movements
class TransactionModel {
  final String transactionId;
  final String? paymentId;
  final String? bookingId;
  final String? hallId;
  final String fromUserId;
  final String toUserId;
  final TransactionType type;
  final TransactionCategory category;
  final double amount;
  final String currency;
  final TransactionStatus status;
  final String description;
  final String? descriptionArabic;
  final DateTime createdAt;
  final DateTime? processedAt;
  final DateTime? completedAt;
  final DateTime? failedAt;
  final String? failureReason;
  final String? referenceId;
  final Map<String, dynamic>? fees;
  final Map<String, dynamic>? metadata;
  final List<TransactionStatusHistory> statusHistory;

  TransactionModel({
    required this.transactionId,
    this.paymentId,
    this.bookingId,
    this.hallId,
    required this.fromUserId,
    required this.toUserId,
    required this.type,
    required this.category,
    required this.amount,
    this.currency = AppConstants.defaultCurrency,
    required this.status,
    required this.description,
    this.descriptionArabic,
    DateTime? createdAt,
    this.processedAt,
    this.completedAt,
    this.failedAt,
    this.failureReason,
    this.referenceId,
    this.fees,
    this.metadata,
    this.statusHistory = const [],
  }) : createdAt = createdAt ?? DateTime.now();

  // ========== Factory Constructors ==========

  /// Create from Firestore document
  factory TransactionModel.fromJson(Map<String, dynamic> json) {
    try {
      return TransactionModel(
        transactionId: Validators.validateString(json['transactionId'], 'Transaction ID'),
        paymentId: json[FirebaseConstants.paymentIdField] as String?,
        bookingId: json[FirebaseConstants.bookingIdField] as String?,
        hallId: json[FirebaseConstants.hallIdField] as String?,
        fromUserId: Validators.validateString(json['fromUserId'], 'From User ID'),
        toUserId: Validators.validateString(json['toUserId'], 'To User ID'),
        type: TransactionType.values.firstWhere(
              (e) => e.name == json['type'],
          orElse: () => TransactionType.payment,
        ),
        category: TransactionCategory.values.firstWhere(
              (e) => e.name == json['category'],
          orElse: () => TransactionCategory.booking,
        ),
        amount: Validators.validatePositiveDouble(json[FirebaseConstants.amountField], 'Amount'),
        currency: json['currency'] as String? ?? AppConstants.defaultCurrency,
        status: TransactionStatus.values.firstWhere(
              (e) => e.name == json[FirebaseConstants.statusField],
          orElse: () => TransactionStatus.pending,
        ),
        description: Validators.validateString(json['description'], 'Description'),
        descriptionArabic: json['descriptionArabic'] as String?,
        createdAt: DateUtils.parseTimestamp(json[FirebaseConstants.createdAtField]) ?? DateTime.now(),
        processedAt: DateUtils.parseTimestamp(json['processedAt']),
        completedAt: DateUtils.parseTimestamp(json['completedAt']),
        failedAt: DateUtils.parseTimestamp(json['failedAt']),
        failureReason: json['failureReason'] as String?,
        referenceId: json['referenceId'] as String?,
        fees: json['fees'] as Map<String, dynamic>?,
        metadata: json['metadata'] as Map<String, dynamic>?,
        statusHistory: (json['statusHistory'] as List<dynamic>?)
            ?.map((e) => TransactionStatusHistory.fromJson(e as Map<String, dynamic>))
            .toList() ?? [],
      );
    } catch (e) {
      throw ModelParseException('Failed to parse TransactionModel: $e');
    }
  }

  /// Create new transaction
  factory TransactionModel.create({
    String? paymentId,
    String? bookingId,
    String? hallId,
    required String fromUserId,
    required String toUserId,
    required TransactionType type,
    required TransactionCategory category,
    required double amount,
    String currency = AppConstants.defaultCurrency,
    required String description,
    String? descriptionArabic,
    String? referenceId,
    Map<String, dynamic>? fees,
    Map<String, dynamic>? metadata,
  }) {
    final transactionId = IdGenerator.generateTransactionId();
    final now = DateTime.now();

    return TransactionModel(
      transactionId: '', // Will be generated by service
      paymentId: paymentId,
      bookingId: bookingId,
      hallId: hallId,
      fromUserId: fromUserId,
      toUserId: toUserId,
      type: type,
      category: category,
      amount: amount,
      currency: currency,
      status: TransactionStatus.pending,
      description: description,
      descriptionArabic: descriptionArabic,
      createdAt: now,
      referenceId: referenceId,
      fees: fees,
      metadata: metadata,
      statusHistory: [
        TransactionStatusHistory(
          status: TransactionStatus.pending,
          timestamp: now,
          notes: 'Transaction created',
        ),
      ],
    );
  }

  /// Create customer payment transaction
  factory TransactionModel.customerPayment({
    required String paymentId,
    required String bookingId,
    required String hallId,
    required String customerId,
    required String ownerId,
    required double amount,
    String? description,
    String? descriptionArabic,
    Map<String, dynamic>? metadata,
  }) {
    return TransactionModel.create(
      paymentId: paymentId,
      bookingId: bookingId,
      hallId: hallId,
      fromUserId: customerId,
      toUserId: AppConstants.systemUserId,
      type: TransactionType.payment,
      category: TransactionCategory.booking,
      amount: amount,
      description: description ?? 'Payment for booking',
      descriptionArabic: descriptionArabic ?? 'دفع للحجز',
      metadata: metadata,
    );
  }

  /// Create owner earning transaction
  factory TransactionModel.ownerEarning({
    required String paymentId,
    required String bookingId,
    required String hallId,
    required String ownerId,
    required double amount,
    String? description,
    String? descriptionArabic,
    Map<String, dynamic>? metadata,
  }) {
    return TransactionModel.create(
      paymentId: paymentId,
      bookingId: bookingId,
      hallId: hallId,
      fromUserId: AppConstants.systemUserId,
      toUserId: ownerId,
      type: TransactionType.earning,
      category: TransactionCategory.booking,
      amount: amount,
      description: description ?? 'Earning from booking',
      descriptionArabic: descriptionArabic ?? 'أرباح من الحجز',
      metadata: metadata,
    );
  }

  /// Create commission transaction
  factory TransactionModel.commission({
    required String paymentId,
    required String bookingId,
    required String hallId,
    required String fromUserId,
    required TransactionType type,
    required double amount,
    String? description,
    String? descriptionArabic,
    Map<String, dynamic>? metadata,
  }) {
    return TransactionModel.create(
      paymentId: paymentId,
      bookingId: bookingId,
      hallId: hallId,
      fromUserId: fromUserId,
      toUserId: AppConstants.systemUserId,
      type: type,
      category: TransactionCategory.commission,
      amount: amount,
      description: description ?? 'Commission fee',
      descriptionArabic: descriptionArabic ?? 'رسوم العمولة',
      metadata: metadata,
    );
  }

  /// Create refund transaction
  factory TransactionModel.refund({
    required String paymentId,
    required String bookingId,
    required String hallId,
    required String customerId,
    required double amount,
    required String reason,
    String? reasonArabic,
    Map<String, dynamic>? metadata,
  }) {
    return TransactionModel.create(
      paymentId: paymentId,
      bookingId: bookingId,
      hallId: hallId,
      fromUserId: AppConstants.systemUserId,
      toUserId: customerId,
      type: TransactionType.refund,
      category: TransactionCategory.refund,
      amount: amount,
      description: 'Refund: $reason',
      descriptionArabic: reasonArabic != null ? 'استرداد: $reasonArabic' : null,
      metadata: metadata,
    );
  }

  // ========== Serialization ==========

  Map<String, dynamic> toJson() {
    return {
      'transactionId': transactionId,
      FirebaseConstants.paymentIdField: paymentId,
      FirebaseConstants.bookingIdField: bookingId,
      FirebaseConstants.hallIdField: hallId,
      'fromUserId': fromUserId,
      'toUserId': toUserId,
      'type': type.name,
      'category': category.name,
      FirebaseConstants.amountField: amount,
      'currency': currency,
      FirebaseConstants.statusField: status.name,
      'description': description,
      'descriptionArabic': descriptionArabic,
      FirebaseConstants.createdAtField: FieldValue.serverTimestamp(),
      'processedAt': processedAt != null ? Timestamp.fromDate(processedAt!) : null,
      'completedAt': completedAt != null ? Timestamp.fromDate(completedAt!) : null,
      'failedAt': failedAt != null ? Timestamp.fromDate(failedAt!) : null,
      'failureReason': failureReason,
      'referenceId': referenceId,
      'fees': fees,
      'metadata': metadata,
      'statusHistory': statusHistory.map((h) => h.toJson()).toList(),
    };
  }

  // ========== Business Logic Methods ==========

  /// Check if transaction is pending
  bool isPending() => status == TransactionStatus.pending;

  /// Check if transaction is processing
  bool isProcessing() => status == TransactionStatus.processing;

  /// Check if transaction is completed
  bool isCompleted() => status == TransactionStatus.completed;

  /// Check if transaction failed
  bool isFailed() => status == TransactionStatus.failed;

  /// Check if transaction is cancelled
  bool isCancelled() => status == TransactionStatus.cancelled;

  /// Check if transaction can be cancelled
  bool canBeCancelled() {
    return status == TransactionStatus.pending;
  }

  /// Check if transaction is a debit (outgoing)
  bool isDebit(String userId) {
    return fromUserId == userId;
  }

  /// Check if transaction is a credit (incoming)
  bool isCredit(String userId) {
    return toUserId == userId;
  }

  /// Get transaction direction for user
  TransactionDirection getDirection(String userId) {
    if (isDebit(userId)) return TransactionDirection.outgoing;
    if (isCredit(userId)) return TransactionDirection.incoming;
    return TransactionDirection.neutral;
  }

  /// Get processing time in minutes
  int? getProcessingTimeInMinutes() {
    if (processedAt == null) return null;
    return processedAt!.difference(createdAt).inMinutes;
  }

  /// Get completion time in minutes
  int? getCompletionTimeInMinutes() {
    if (completedAt == null) return null;
    return completedAt!.difference(createdAt).inMinutes;
  }

  /// Get total fees
  double getTotalFees() {
    if (fees == null) return 0.0;
    return fees!.values.fold(0.0, (sum, fee) => sum + (fee as num).toDouble());
  }

  /// Get net amount after fees
  double getNetAmount() {
    return amount - getTotalFees();
  }

  /// Get localized description
  String getLocalizedDescription(String languageCode) {
    if (languageCode == 'ar' && descriptionArabic?.isNotEmpty == true) {
      return descriptionArabic!;
    }
    return description;
  }

  /// Get transaction type display text
  String getTypeDisplayText(String languageCode) {
    final typeTranslations = {
      'payment': {'en': 'Payment', 'ar': 'دفع'},
      'earning': {'en': 'Earning', 'ar': 'أرباح'},
      'commission': {'en': 'Commission', 'ar': 'عمولة'},
      'refund': {'en': 'Refund', 'ar': 'استرداد'},
      'transfer': {'en': 'Transfer', 'ar': 'تحويل'},
      'withdrawal': {'en': 'Withdrawal', 'ar': 'سحب'},
      'fee': {'en': 'Fee', 'ar': 'رسوم'},
    };

    return typeTranslations[type.name]?[languageCode] ?? type.name;
  }

  /// Get transaction category display text
  String getCategoryDisplayText(String languageCode) {
    final categoryTranslations = {
      'booking': {'en': 'Booking', 'ar': 'حجز'},
      'commission': {'en': 'Commission', 'ar': 'عمولة'},
      'refund': {'en': 'Refund', 'ar': 'استرداد'},
      'fee': {'en': 'Fee', 'ar': 'رسوم'},
      'withdrawal': {'en': 'Withdrawal', 'ar': 'سحب'},
      'adjustment': {'en': 'Adjustment', 'ar': 'تعديل'},
    };

    return categoryTranslations[category.name]?[languageCode] ?? category.name;
  }

  /// Get status display text
  String getStatusDisplayText(String languageCode) {
    final statusTranslations = {
      'pending': {'en': 'Pending', 'ar': 'في الانتظار'},
      'processing': {'en': 'Processing', 'ar': 'قيد المعالجة'},
      'completed': {'en': 'Completed', 'ar': 'مكتمل'},
      'failed': {'en': 'Failed', 'ar': 'فشل'},
      'cancelled': {'en': 'Cancelled', 'ar': 'ملغي'},
    };

    return statusTranslations[status.name]?[languageCode] ?? status.name;
  }

  /// Format amount with currency and direction
  String getFormattedAmount({String? languageCode, String? forUserId}) {
    final formatted = amount.toStringAsFixed(3);
    final currencySymbol = AppConstants.currencySymbol;
    final direction = forUserId != null ? getDirection(forUserId) : TransactionDirection.neutral;

    String prefix = '';
    if (direction == TransactionDirection.outgoing) {
      prefix = '-';
    } else if (direction == TransactionDirection.incoming) {
      prefix = '+';
    }

    if (languageCode == 'ar') {
      return '$prefix$formatted $currencySymbol';
    }
    return '$prefix$currencySymbol $formatted';
  }

  // ========== Update Methods ==========

  /// Mark transaction as processing
  TransactionModel markAsProcessing() {
    final now = DateTime.now();
    final newHistory = List<TransactionStatusHistory>.from(statusHistory)
      ..add(TransactionStatusHistory(
        status: TransactionStatus.processing,
        timestamp: now,
        notes: 'Transaction processing started',
      ));

    return copyWith(
      status: TransactionStatus.processing,
      processedAt: now,
      statusHistory: newHistory,
    );
  }

  /// Complete transaction
  TransactionModel complete() {
    final now = DateTime.now();
    final newHistory = List<TransactionStatusHistory>.from(statusHistory)
      ..add(TransactionStatusHistory(
        status: TransactionStatus.completed,
        timestamp: now,
        notes: 'Transaction completed successfully',
      ));

    return copyWith(
      status: TransactionStatus.completed,
      completedAt: now,
      statusHistory: newHistory,
    );
  }

  /// Fail transaction
  TransactionModel fail(String reason) {
    final now = DateTime.now();
    final newHistory = List<TransactionStatusHistory>.from(statusHistory)
      ..add(TransactionStatusHistory(
        status: TransactionStatus.failed,
        timestamp: now,
        notes: 'Transaction failed: $reason',
      ));

    return copyWith(
      status: TransactionStatus.failed,
      failedAt: now,
      failureReason: reason,
      statusHistory: newHistory,
    );
  }

  /// Cancel transaction
  TransactionModel cancel(String reason) {
    final now = DateTime.now();
    final newHistory = List<TransactionStatusHistory>.from(statusHistory)
      ..add(TransactionStatusHistory(
        status: TransactionStatus.cancelled,
        timestamp: now,
        notes: 'Transaction cancelled: $reason',
      ));

    return copyWith(
      status: TransactionStatus.cancelled,
      failureReason: reason,
      statusHistory: newHistory,
    );
  }

  // ========== Copy With ==========

  TransactionModel copyWith({
    String? transactionId,
    String? paymentId,
    String? bookingId,
    String? hallId,
    String? fromUserId,
    String? toUserId,
    TransactionType? type,
    TransactionCategory? category,
    double? amount,
    String? currency,
    TransactionStatus? status,
    String? description,
    String? descriptionArabic,
    DateTime? createdAt,
    DateTime? processedAt,
    DateTime? completedAt,
    DateTime? failedAt,
    String? failureReason,
    String? referenceId,
    Map<String, dynamic>? fees,
    Map<String, dynamic>? metadata,
    List<TransactionStatusHistory>? statusHistory,
  }) {
    return TransactionModel(
      transactionId: transactionId ?? this.transactionId,
      paymentId: paymentId ?? this.paymentId,
      bookingId: bookingId ?? this.bookingId,
      hallId: hallId ?? this.hallId,
      fromUserId: fromUserId ?? this.fromUserId,
      toUserId: toUserId ?? this.toUserId,
      type: type ?? this.type,
      category: category ?? this.category,
      amount: amount ?? this.amount,
      currency: currency ?? this.currency,
      status: status ?? this.status,
      description: description ?? this.description,
      descriptionArabic: descriptionArabic ?? this.descriptionArabic,
      createdAt: createdAt ?? this.createdAt,
      processedAt: processedAt ?? this.processedAt,
      completedAt: completedAt ?? this.completedAt,
      failedAt: failedAt ?? this.failedAt,
      failureReason: failureReason ?? this.failureReason,
      referenceId: referenceId ?? this.referenceId,
      fees: fees ?? this.fees,
      metadata: metadata ?? this.metadata,
      statusHistory: statusHistory ?? this.statusHistory,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is TransactionModel && other.transactionId == transactionId;
  }

  @override
  int get hashCode => transactionId.hashCode;

  @override
  String toString() => 'TransactionModel(id: $transactionId, amount: $amount, type: $type)';
}

// ========== Supporting Enums ==========

/// Transaction type enum
enum TransactionType {
  payment,
  earning,
  commission,
  refund,
  transfer,
  withdrawal,
  fee,
}

/// Transaction category enum
enum TransactionCategory {
  booking,
  commission,
  refund,
  fee,
  withdrawal,
  adjustment,
}

/// Transaction status enum
enum TransactionStatus {
  pending,
  processing,
  completed,
  failed,
  cancelled,
}

/// Transaction direction enum
enum TransactionDirection {
  incoming,
  outgoing,
  neutral,
}

// ========== Supporting Models ==========

/// Transaction status history tracking
class TransactionStatusHistory {
  final TransactionStatus status;
  final DateTime timestamp;
  final String? notes;
  final Map<String, dynamic>? metadata;

  TransactionStatusHistory({
    required this.status,
    required this.timestamp,
    this.notes,
    this.metadata,
  });

  factory TransactionStatusHistory.fromJson(Map<String, dynamic> json) {
    return TransactionStatusHistory(
      status: TransactionStatus.values.firstWhere(
            (e) => e.name == json['status'],
        orElse: () => TransactionStatus.pending,
      ),
      timestamp: DateUtils.parseTimestamp(json['timestamp']) ?? DateTime.now(),
      notes: json['notes'] as String?,
      metadata: json['metadata'] as Map<String, dynamic>?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'status': status.name,
      'timestamp': Timestamp.fromDate(timestamp),
      'notes': notes,
      'metadata': metadata,
    };
  }
}

/// Transaction summary for reporting
class TransactionSummary {
  final double totalIncoming;
  final double totalOutgoing;
  final double netAmount;
  final int transactionCount;
  final DateTime? lastTransactionDate;

  TransactionSummary({
    required this.totalIncoming,
    required this.totalOutgoing,
    required this.netAmount,
    required this.transactionCount,
    this.lastTransactionDate,
  });

  factory TransactionSummary.fromTransactions(List<TransactionModel> transactions, String userId) {
    double totalIncoming = 0.0;
    double totalOutgoing = 0.0;
    DateTime? lastTransactionDate;

    for (final transaction in transactions) {
      if (transaction.isCredit(userId)) {
        totalIncoming += transaction.amount;
      } else if (transaction.isDebit(userId)) {
        totalOutgoing += transaction.amount;
      }

      if (lastTransactionDate == null || transaction.createdAt.isAfter(lastTransactionDate)) {
        lastTransactionDate = transaction.createdAt;
      }
    }

    return TransactionSummary(
      totalIncoming: totalIncoming,
      totalOutgoing: totalOutgoing,
      netAmount: totalIncoming - totalOutgoing,
      transactionCount: transactions.length,
      lastTransactionDate: lastTransactionDate,
    );
  }

  @override
  String toString() => 'TransactionSummary(net: $netAmount, count: $transactionCount)';
}

/// Custom exception for transaction model parsing errors
class ModelParseException implements Exception {
  final String message;
  ModelParseException(this.message);

  @override
  String toString() => 'ModelParseException: $message';
}